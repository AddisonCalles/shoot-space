function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var Drawable = /*#__PURE__*/function () {
  function Drawable(_canvas, _x, _y, _width, _height) {
    if (_width === void 0) {
      _width = 0;
    }

    if (_height === void 0) {
      _height = 0;
    }

    this._offset = {
      x: 0,
      y: 0
    };
    this._layers = [];
    this._rotation = 0;
    this._debug = false;
    this._width = _width;
    this._height = _height;
    this._x = _x;
    this._y = _y;
    this._ctx = _canvas.getContext('2d');
    this._canvas = _canvas;
  }

  var _proto = Drawable.prototype;

  _proto.setLeyers = function setLeyers(layers) {
    this._layers = layers;
  };

  _proto.move = function move(x, y) {
    this._x += x;
    this._y += y;
  };

  _proto.rotate = function rotate(angle) {
    this._rotation = this._rotation + angle;
  };

  _proto.setPos = function setPos(x, y) {
    this._x = x;
    this._y = y;
  };

  _proto.setCanvas = function setCanvas(canvas) {
    this._canvas = canvas;
    this._ctx = this._canvas.getContext('2d');
  };

  _proto.centerOffset = function centerOffset() {
    this._offset = {
      x: this.width / 2,
      y: this.height / 2
    };
  };

  _proto.render = function render() {
    this._layers.forEach(function (layer) {
      layer.render();
    });

    if (this._debug) {
      this.context.fillStyle = 'orange';
      this.context.font = "10px Arial";
      this.context.fillText("(" + this.x.toFixed() + "," + this.y.toFixed(0) + ")", this.x - 10, this.y - 10);
      this.context.strokeStyle = 'gray';
      this.context.strokeRect(this.x, this.y, this.width, this.height);
      this.context.beginPath();
      this.context.arc(this.x, this.y, 4, 0, Math.PI * 2);
      this.context.fill();
    }
  };

  _proto.enableDebug = function enableDebug() {
    this._debug = true;
  };

  _createClass(Drawable, [{
    key: "context",
    get: function get() {
      return this._ctx;
    }
  }, {
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
  }, {
    key: "x",
    get: function get() {
      return this._x + this._offset.x;
    }
  }, {
    key: "y",
    get: function get() {
      return this._y + this._offset.y;
    }
  }, {
    key: "x2",
    get: function get() {
      return this.x + this._width;
    }
  }, {
    key: "y2",
    get: function get() {
      return this.y + this._height;
    }
  }, {
    key: "rotation",
    get: function get() {
      return this._rotation;
    },
    set: function set(value) {
      this._rotation = value;
    }
  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
  }, {
    key: "offset",
    get: function get() {
      return this._offset;
    },
    set: function set(value) {
      this._offset = value;
    }
  }]);

  return Drawable;
}();

var EventListener = /*#__PURE__*/function () {
  function EventListener() {
    this._listeners = [];
  }

  var _proto = EventListener.prototype;

  _proto.subscribe = function subscribe(listener) {
    this._listeners.push(listener);
  };

  _proto.unsubscribe = function unsubscribe(listener) {
    this._listeners = this._listeners.filter(function (inlist) {
      return inlist !== listener;
    });
  };

  _proto.emit = function emit(params) {
    this._listeners.forEach(function (listener) {
      return listener(params);
    });
  };

  return EventListener;
}();

var random = function random(max, min) {
  return Math.random() * (max - min) + min;
};
var angleBetweenPoints = function angleBetweenPoints(p1, p2) {
  return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
};
var vectorComponents = function vectorComponents(direction, velocity) {
  var radians = direction * Math.PI / 180;
  return {
    x: velocity * Math.cos(radians),
    y: velocity * Math.sin(radians)
  };
};
var vectorByXY = function vectorByXY(vX, vY) {
  return {
    vel: Math.abs(Math.pow(Math.pow(vX, 2) + Math.pow(vY, 2), 1) / 2),
    dir: Math.atan(vY / vX)
  };
};

var math = {
  __proto__: null,
  random: random,
  angleBetweenPoints: angleBetweenPoints,
  vectorComponents: vectorComponents,
  vectorByXY: vectorByXY
};

function rgba(color, transparency) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
  return result ? "rgba(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ", " + transparency + ")" : '';
}

var color = {
  __proto__: null,
  rgba: rgba
};

var Game = /*#__PURE__*/function () {
  function Game(canvas) {
    this._play = false;
    this._level = 0;
    this._context = {};
    this._points = 0;
    this._canvas = {};
    this._gameover = false;
    this._playEvent = new EventListener();
    this._preloadEvent = new EventListener();
    this._gameOverEvent = new EventListener();
    this._renderEvent = new EventListener();
    this._nextLevelEvent = new EventListener();
    this._fps = 1;
    this._fpsCounter = 0;
    this._time = 0;
    this._initTime = 0;
    this._lastTime = 0;
    this._controls = {
      fire: new EventListener(),
      move: new EventListener(),
      jump: new EventListener()
    };
    this._canvas = canvas;
    this._context = canvas == null ? void 0 : canvas.getContext('2d');

    this._preloadEvent.emit(this);
  }

  var _proto = Game.prototype;

  _proto.render = function render() {
    if (!this._context) return;

    this._renderEvent.emit(this);
  };

  _proto._initMouseEvents = function _initMouseEvents() {
    var _this$_canvas, _this$_canvas2;

    var gameRef = this;
    (_this$_canvas = this._canvas) == null ? void 0 : _this$_canvas.addEventListener('click', function (event) {
      gameRef._controls.fire.emit({
        context: gameRef,
        event: event
      });
    });
    (_this$_canvas2 = this._canvas) == null ? void 0 : _this$_canvas2.addEventListener('mousemove', function (event) {
      gameRef._controls.move.emit({
        context: gameRef,
        event: event
      });
    });
  };

  _proto.clearCanvas = function clearCanvas() {
    var _this$_context, _this$_canvas3, _this$_canvas4;

    if (this._context && this._canvas) (_this$_context = this._context) == null ? void 0 : _this$_context.clearRect(0, 0, (_this$_canvas3 = this._canvas) == null ? void 0 : _this$_canvas3.width, (_this$_canvas4 = this._canvas) == null ? void 0 : _this$_canvas4.height);
  };

  _proto.play = function play() {
    this._play = true;
  };

  _proto.nextLevel = function nextLevel(sleepOffset) {
    if (sleepOffset === void 0) {
      sleepOffset = 0;
    }

    this._level++;
    setTimeout(function () {}, sleepOffset);
  };

  _proto.start = function start() {
    var _this = this;

    this._initTime = new Date().getTime();
    this._mainRunner = setInterval(function () {
      _this.clearCanvas();

      _this.render();

      var now = new Date().getTime();
      var milliSecondsDif = now - _this._lastTime;
      _this._time = +((now - _this._initTime) / 1000).toFixed(0);

      if (milliSecondsDif >= 1000) {
        _this._lastTime = new Date().getTime();
        _this._fps = _this._fpsCounter;
        _this._fpsCounter = 0;
      }

      _this._fpsCounter++;
    }, 1000 / 60);
  };

  _proto.stop = function stop() {
    clearInterval(this._mainRunner);
  };

  _proto.incrementPoints = function incrementPoints(amount) {
    return this._points += amount;
  };

  _createClass(Game, [{
    key: "gameOverEvent",
    get: function get() {
      return this._gameOverEvent;
    }
  }, {
    key: "nextLevelEvent",
    get: function get() {
      return this._nextLevelEvent;
    }
  }, {
    key: "playEvent",
    get: function get() {
      return this._playEvent;
    }
  }, {
    key: "gameOver",
    get: function get() {
      return this._gameover;
    }
  }, {
    key: "points",
    get: function get() {
      return this._points;
    }
  }, {
    key: "level",
    get: function get() {
      return this._level;
    }
  }, {
    key: "isPlay",
    get: function get() {
      return this._play;
    }
  }, {
    key: "time",
    get: function get() {
      return this._time;
    }
  }, {
    key: "fps",
    get: function get() {
      return this._fps;
    }
  }]);

  return Game;
}();

var Health = /*#__PURE__*/function () {
  function Health(total) {
    this._reduceEvent = new EventListener();
    this._deadEvent = new EventListener();
    this._total = total;
    this._health = total;
  }

  var _proto = Health.prototype;

  _proto.reset = function reset() {
    this._health = this._total;
  };

  _proto.reduce = function reduce(_reduce) {
    var health = this._health - _reduce;

    if (health <= 0) {
      this._health = 0;
      this.deadEvent.emit(this);
    } else {
      this._health = health;
    }
  };

  _createClass(Health, [{
    key: "current",
    get: function get() {
      return this._health;
    }
  }, {
    key: "total",
    get: function get() {
      return this._total;
    }
  }, {
    key: "reduceEvent",
    get: function get() {
      return this._reduceEvent;
    }
  }, {
    key: "deadEvent",
    get: function get() {
      return this._deadEvent;
    }
  }, {
    key: "isDead",
    get: function get() {
      return this.current <= 0;
    }
  }]);

  return Health;
}();

var Vector = /*#__PURE__*/function () {
  function Vector(element) {
    this._vel = 0;
    this._dir = 0;
    this._velX = 0;
    this._velY = 0;
    this._element = element;
  }

  var _proto = Vector.prototype;

  _proto.setVel = function setVel(velocity) {
    this.setVector(velocity, this._dir);
  };

  _proto.setDir = function setDir(_dir) {
    this.setVector(this._vel, _dir);
  };

  _proto.rotate = function rotate(grades) {
    var sum = this._dir + grades;
    this._dir = sum % 360;
    this.setVector(this._vel, this._dir);
  };

  _proto.rotateTo = function rotateTo(element) {
    var angleBetweenElements = angleBetweenPoints(this._element, element);
    this.setDir(angleBetweenElements);
  };

  _proto.setVector = function setVector(_vel, _dir) {
    this._vel = Math.abs(_vel);
    this._dir = _dir;
    var components = vectorComponents(this._dir, this._vel);
    this._velX = components.x;
    this._velY = components.y;
  };

  _proto.setVelXY = function setVelXY(velx, vely) {
    this._velX = velx;
    this._velY = vely;
    var vector = vectorByXY(velx, vely);
    this._vel = vector.vel;
    this._dir = vector.dir;
  };

  _createClass(Vector, [{
    key: "vel",
    get: function get() {
      return {
        vel: this._vel,
        x: this._velX,
        y: this._velY
      };
    }
  }, {
    key: "dir",
    get: function get() {
      return this._dir;
    }
  }]);

  return Vector;
}();

var Kinematic = /*#__PURE__*/function (_Drawable) {
  _inheritsLoose(Kinematic, _Drawable);

  function Kinematic(canvas, x, y, width, height) {
    var _this;

    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    _this = _Drawable.call(this, canvas, x, y, width, height) || this;
    _this._destroy = false;
    _this._vector = new Vector(_assertThisInitialized(_this));
    _this._enabledVectorRotation = true;
    _this._path = new Path2D();

    _this._vector.setVector(0, 0);

    return _this;
  }

  var _proto = Kinematic.prototype;

  _proto.edgeColision = function edgeColision() {
    if (this.x <= 0 && this._vector.vel.x < 0) {
      return 'right';
    } else if (this.x2 >= this.canvas.width && this._vector.vel.x > 0) {
      return 'left';
    }

    if (this.y <= 0 && this._vector.vel.y < 0) {
      return 'top';
    } else if (this.y2 >= this.canvas.height && this._vector.vel.y > 0) {
      return 'bottom';
    }

    return false;
  };

  _proto.hasColision = function hasColision(el) {
    var xColision = false;

    if (this.x <= el.x2 && el.x <= this.x2) {
      xColision = true;
    } else if (this.x2 >= el.x && this.x2 <= el.x2) {
      xColision = true;
    }

    var yColision = false;

    if (this.y <= el.y2 && el.y <= this.y2) {
      yColision = true;
    } else if (this.y2 >= el.y && this.y2 <= el.y2) {
      yColision = true;
    }

    return xColision && yColision;
  };

  _proto.move = function move() {
    _Drawable.prototype.move.call(this, this._vector.vel.x, this._vector.vel.y);
  };

  _proto.isDestroy = function isDestroy() {
    return this._destroy;
  };

  _proto.destroy = function destroy() {
    this._destroy = true;
  };

  _createClass(Kinematic, [{
    key: "vector",
    get: function get() {
      return this._vector;
    }
  }, {
    key: "path",
    get: function get() {
      return this._path;
    }
  }, {
    key: "enabledVectorRotation",
    get: function get() {
      return this._enabledVectorRotation;
    },
    set: function set(value) {
      this._enabledVectorRotation = value;
    }
  }]);

  return Kinematic;
}(Drawable);

var LayerPath = /*#__PURE__*/function () {
  function LayerPath(path, color, element) {
    this._rotation = 0;
    this._color = color;
    this._path = path;
    this._originalPath = path;
    this._element = element;
  }

  var _proto = LayerPath.prototype;

  _proto.rotate = function rotate(direction) {
    var rotatePath = new Path2D();
    rotatePath.addPath(this._originalPath, DOMMatrix.fromMatrix().translate(this._element.width / 2, this._element.height / 2).rotate(direction).translate(this._element.width / 2 * -1, this._element.height / 2 * -1));
    this._path = new Path2D();
    this.path.addPath(rotatePath, DOMMatrix.fromMatrix().translate(this._element.x, this._element.y));
  };

  _proto.render = function render() {
    var rotation = this.rotation + this._element.rotation + (this._element.enabledVectorRotation ? this._element.vector.dir : 0);
    this.rotate(rotation);
    this._element.context.fillStyle = this.color;

    this._element.context.fill(this._path);
  };

  _createClass(LayerPath, [{
    key: "rotation",
    get: function get() {
      return this._rotation;
    },
    set: function set(value) {
      this._rotation = value;
    }
  }, {
    key: "color",
    get: function get() {
      return this._color;
    }
  }, {
    key: "path",
    get: function get() {
      return this._path;
    }
  }]);

  return LayerPath;
}();

var Point = function Point(x, y) {
  if (x === void 0) {
    x = 0;
  }

  if (y === void 0) {
    y = 0;
  }

  this.x = x;
  this.y = y;
};

export { Drawable, EventListener, Game, Health, Kinematic, LayerPath, Point, Vector, color, math };
//# sourceMappingURL=streetzero.esm.js.map
